/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package de.appwerft.ftp4j;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import it.sauronsoftware.ftp4j.FTPAbortedException;
import it.sauronsoftware.ftp4j.FTPClient;
import it.sauronsoftware.ftp4j.FTPDataTransferException;
import it.sauronsoftware.ftp4j.FTPDataTransferListener;
import it.sauronsoftware.ftp4j.FTPException;
import it.sauronsoftware.ftp4j.FTPFile;
import it.sauronsoftware.ftp4j.FTPIllegalReplyException;
import it.sauronsoftware.ftp4j.FTPListParseException;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.titanium.TiC;

import android.os.AsyncTask;

@Kroll.proxy(creatableInModule = Ftp4jModule.class)
public class FTPclientProxy extends KrollProxy {
	private static final String LCAT = "FTP4j";
	private String host;
	private String login = "anonymous";
	private String password = "ftp4j";
	private int port = 0;

	private String fullPath = "/";
	private String directory = null;
	private String fileName = null;
	private FTPClient client = new FTPClient();
	private KrollFunction onLoad;
	private KrollFunction onError;

	public FTPclientProxy() {
		super();
	}

	@Override
	public void handleCreationDict(KrollDict opts) {
		super.handleCreationDict(opts);
		if (opts.containsKeyAndNotNull(TiC.PROPERTY_ONLOAD)) {
			Object o = opts.get(TiC.PROPERTY_ONLOAD);
			if (o instanceof KrollFunction) {
				onLoad = (KrollFunction) o;
			}
		}
		if (opts.containsKeyAndNotNull(TiC.PROPERTY_ONERROR)) {
			Object o = opts.get(TiC.PROPERTY_ONERROR);
			if (o instanceof KrollFunction) {
				onError = (KrollFunction) o;
			}
		}
		if (opts.containsKeyAndNotNull(TiC.PROPERTY_URL)) {
			try {
				URL url = new URL(opts.getString(TiC.PROPERTY_URL));
				host = url.getHost();
				String user;
				user = url.getUserInfo();
				if (user != null && user.contains(":")) {
					login = user.split(":")[0];
					password = user.split(":")[1];
				}
				port = url.getPort();
				fullPath = url.getPath();
			} catch (MalformedURLException e) {
				Log.e(LCAT,
						"wrong format url " + opts.getString(TiC.PROPERTY_URL));
				e.printStackTrace();
				sendError("malformedIURL", 0);
			}
		}
		String[] parts = fullPath.split("/");
		if (parts[parts.length - 1].equals("")) {
			/* pure path without file */
			directory = fullPath;
		} else {
			fileName = parts[parts.length - 1];
			directory = fullPath.substring(0,
					fullPath.length() - fileName.length());
		}
		(new FTPsessionConnect()).execute();

	}

	@Kroll.method
	public void disconnect() {
		if (client != null && client.isConnected()) {
			Thread t = new Thread() {
				public void run() {
					try {
						client.disconnect(true);
					} catch (IllegalStateException | IOException
							| FTPIllegalReplyException | FTPException e) {
						e.printStackTrace();
						sendError(e.getMessage(), 0);
					}
				}
			};
			t.start();
		}
	}

	@Kroll.method
	public boolean isConnected() {
		return client.isConnected();
	}

	private class FTPsessionConnect extends AsyncTask<String, Void, String> {
		@Override
		protected String doInBackground(String... params) {
			KrollDict kd = new KrollDict();
			try {
				if (port != 0)
					client.connect(host, port);
				else
					client.connect(host);
			} catch (IllegalStateException | IOException
					| FTPIllegalReplyException | FTPException e1) {
				e1.printStackTrace();
				sendError(e1.getMessage(), 0);
				return "E";
			}
			try {
				client.login(login, password);
			} catch (IllegalStateException | IOException
					| FTPIllegalReplyException | FTPException e1) {
				e1.printStackTrace();
				sendError(e1.getMessage(), 0);
				return "E";
			}
			if (!client.isConnected())
				return "";
			try {
				client.changeDirectory("." + directory);
			} catch (IllegalStateException | IOException
					| FTPIllegalReplyException | FTPException e1) {
				e1.printStackTrace();
				sendError(e1.getMessage(), 0);
				return "E";
			}
			String[] fileList = null;
			try {
				try {
					fileList = client.listNames();
				} catch (IllegalStateException | IOException
						| FTPIllegalReplyException | FTPException e1) {
					e1.printStackTrace();
				}
			} catch (FTPDataTransferException | FTPAbortedException
					| FTPListParseException e) {
				e.printStackTrace();
				sendError(e.getMessage(), 0);
			}
			try {
				kd.put("currentDirectory", client.currentDirectory());
			} catch (IllegalStateException | IOException
					| FTPIllegalReplyException | FTPException e1) {
				sendError(e1.getMessage(), 0);
				e1.printStackTrace();
				return "E";
			}

			kd.put("fileNames", fileList);
			if (onLoad != null) {
				onLoad.call(getKrollObject(), kd);
			}
			if (fileName != null) {
				try {
					File tempFile = File.createTempFile(fileName, ".tmp");
					client.download(fileName, tempFile,
							new MyTransferListener());
				} catch (IllegalStateException | IOException
						| FTPIllegalReplyException | FTPException
						| FTPDataTransferException | FTPAbortedException e) {
					e.printStackTrace();
					sendError(e.getMessage(), 0);
				}
			}
			return "Executed";
		}

	}

	private void sendError(String message, int number) {
		if (onError != null) {
			KrollDict kd = new KrollDict();
			kd.put("message", message);
			kd.put("error", number);
			onError.call(getKrollObject(), kd);
		}

	}

	public class MyTransferListener implements FTPDataTransferListener {
		int transfered = 0;

		public void started() {
			Log.d(LCAT, "Transfer started");
			// Transfer started
		}

		public void transferred(int length) {
			transfered += length;
			Log.d(LCAT, "length=" + transfered);
			// Yet other length bytes has been transferred since the last time
			// this
			// method was called
		}

		public void completed() {
			Log.d(LCAT, "Transfer complete");
			// Transfer completed
		}

		public void aborted() {
			// Transfer aborted
		}

		public void failed() {
			// Transfer failed
		}

	}
}